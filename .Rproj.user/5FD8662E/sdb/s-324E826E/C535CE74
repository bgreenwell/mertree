{
    "contents" : "#' Regression Trees for Longitudinal and Panel Data\n#'\n#' Fits an unbiased regression tree to longitudinal or panel data by iterating\n#' back and forth between a conditional inference regression tree to capture\n#' complex interactions and nonlinear relationaships and a linear mixed-effects\n#' model to capture complex correlation structure.\n#'\n#' @param formula An appropriate \\code{\\link{lmer}}-style formula.\n#' @param data An optional data frame containing the variables named in\n#'   \\code{formula}.\n#' @param unbiased Logical indicating whether or not to use a conditional\n#'   inference tree. Default is \\code{TRUE}.\n#' @param initial_re Numeric vector containing the initial values for the random\n#'   effects. If omitted then defaults to zero.\n#' @param REML Logical indicating whether or not the estimates should be chosen\n#'   to optimize the REML criterion (as opposed to the log-likelihood).\n#' @param lmer.control List of control parameters for \\code{\\link{lmer}}.\n#' @param tree.control List of control parameters for \\code{\\link{ctree}} or\n#'   \\code{\\link{rpart}}.\n#' @param tol The desired accuracy (convergence tolerance). Default is\n#'   \\code{0.001)}\n#' @param maxiter Integer specifying the maximum number of iterations. Default\n#'   is \\code{1000}.\n#' @param do.trace Logical indicating whether or not to print trace information.\n#'\n#' @importFrom lme4 lmer lmerControl\n#' @importFrom party ctree ctree_control where\n#' @importFrom rpart prune rpart rpart.control\n#' @importFrom stats logLik predict\n#'\n#' @export\n#'\n#' @examples\n#' data(Orthodont, package = \"nlme\")\n#' fm <- mertree(distance ~ age + Sex + (1 | Subject), data = Orthodont)\n#' fm2 <- mertree(distance ~ age + Sex + (1 | Subject), data = Orthodont,\n#'                unbiased = FALSE)\nmertree <- function (formula, data, unbiased = TRUE, initial_re, REML = TRUE,\n                     lmer.control = lmerControl(calc.derivs = FALSE),\n                     tree.control = if (unbiased) ctree_control(mincriterion = 0.95) else rpart.control(),\n                     cv = TRUE, tol = 0.001, maxiter = 100L, do.trace = FALSE) {\n\n  # Initialize random effects estimate\n  if (missing(initial_re)) {\n    initial_re <- numeric(length = dim(data)[1L])\n  }\n\n  # Extract formula components\n  response_name <- get_response_name(formula)\n  fixed_formula <- get_fixed_formula(formula)\n  random_formula <- get_random_formula(formula)\n\n  # Vector of response values and adjusted response values\n  response_values <- data[[response_name]]\n  adj_response_values <- response_values - initial_re\n\n  # Initialize loop control variables\n  continue_condition <- TRUE\n  iter <- 0\n  old_logLik <- -Inf\n\n  # Copy of original data\n  newdata <- data\n\n  # Iterate back and forth between a conditional inference tree and a linear\n  # mixed-effects model\n  while (continue_condition) {\n\n    if (do.trace) {\n      cat(paste0(\"iter \", iter + 1, \":\"), \"\\n\")\n    }\n\n    # Add column of adjusted response values\n    newdata[[\"adj_response_values\"]] <- adj_response_values\n\n    ############################################################################\n    # Regression tree\n    ############################################################################\n\n    if (do.trace) {\n      cat(\"  1. fitting tree...\", \"\\n\")\n    }\n\n#     form <- make_tree_formula(\"adj_response_values\", fixed = fixed_formula)\n#     print(form)\n#     print(tree.control)\n\n    # Fit a conditional inference tree\n    if (unbiased) {\n      tree_fit <- ctree(make_tree_formula(\"adj_response_values\",\n                                          fixed = fixed_formula),\n                        data = newdata, controls = tree.control)\n    }\n    # Fit a CART-like regression tree\n    else {\n      if (cv) {\n        temp <- rpart(make_tree_formula(\"adj_response_values\",\n                                        fixed = fixed_formula),\n                      data = newdata, control = tree.control)\n        opt <- temp$cptable[which.min(temp$cptable[, \"xerror\"]), \"CP\"]\n        tree_fit <- prune(temp, cp = opt)\n      } else {\n        tree_fit <- rpart(make_tree_formula(\"adj_response_values\",\n                                            fixed = fixed_formula),\n                          data = newdata, control = tree.control(xval = 0))\n      }\n\n    }\n\n    # Add terminal node indicator variable\n    .where <- if (unbiased) where(tree_fit) else tree_fit$where\n    newdata[[\"terminal_node\"]] <- as.factor(.where)\n\n\n    ############################################################################\n    # Linear mixed-effects model\n    ############################################################################\n\n    if (do.trace) {\n      cat(\"  2. fitting mixed-effects model...\", \"\\n\\n\")\n    }\n\n    # If the tree is a root (i.e., has no splits), then just fit an intercept\n    if (min(.where) == max(.where)) {\n      lmer_fit <- lmer(make_lmer_formula(response_name, fixed = \"1\"),\n                       data = newdata, REML = REML, control = lmer.control)\n    }\n    # Otherwise, fit an linear mixed-effects model using a factor for terminal\n    # node indicator as the fixed effects\n    else {\n      lmer_fit <- lmer(make_lmer_formula(response_name, fixed = \"terminal_node\",\n                                         random = random_formula),\n                       data = newdata, REML = REML, control = lmer.control)\n    }\n\n    # Update loop control variables\n    iter <- iter + 1\n    new_logLik <- logLik(lmer_fit)\n    continue_condition <- (new_logLik - old_logLik) > tol & iter < maxiter\n    old_logLik <- new_logLik\n\n    # Update adjusted response values\n    adj_response_values <- response_values -\n      (predict(lmer_fit, re.form = NULL) - predict(lmer_fit, re.form = NA))\n       # all random effects (XB + Zb)      # no random effects (XB)\n\n  }\n\n  # Print warning message about terminal node means\n  warning(\"terminal node estimates are incorrect\")\n\n  mcall <- match.call()\n\n  # Return classed list of results\n  res <- list(\"tree_fit\" = tree_fit,\n              \"lmer_fit\" = lmer_fit,\n              \"iter\" = iter,\n              \"call\" = mcall)\n  class(res) <- \"mertree\"\n  res\n\n}\n\n\n#' Variable Importance Scores\n#'\n#' Variable importance scores for \\code{\"mertree\"} objects.\n#'\n#' @param object An object that inherits from class \\code{\"mertree\"}.\n#' @export\nvarimp <- function(object, ...) {\n  stopifnot(inherits(object, \"mertree\"))\n  if (inherits(object$tree_fit, \"rpart\")) {\n    object$tree_fit$variable.importance\n  } else {\n    stop(paste(\"mertree variable importance scores are not\",\n               \"availble when unbiased = TRUE\"))\n  }\n}\n\n\n#' @method plot mertree\n#' @importFrom graphics plot\n#' @importFrom rpart.plot prp\n#' @export\nplot.mertree <- function(object, ...) {\n  if (inherits(object$tree_fit, \"rpart\")) {\n    prp(object$tree_fit, ...)\n  } else {\n    plot(object$tree_fit, ...)\n  }\n}\n\n\n#' @method text mertree\n#' @importFrom graphics text\n#' @export\ntext.mertree <- function(object, ...) {\n  text(object$tree_fit, ...)\n}\n\n\n#' @method print mertree\n#' @export\nprint.mertree <- function(object, ...) {\n  print(object$lmer_fit)\n}\n\n\n#' @method summary mertree\n#' @export\nsummary.mertree <- function(object, ...) {\n  summary(object$lmer_fit)\n}\n\n\n#' @method confint mertree\n#' @importFrom stats confint\n#' @export\nconfint.mertree <- function(object, ...) {\n  confint(object$lmer_fit, ...)\n}\n\n\n#' @method predict mertree\n#' @importFrom stats predict\n#' @export\npredict.mertree <- function(object, newdata, ...) {\n  predict(object$lmer_fit, re.form = NA, ...)\n}\n",
    "created" : 1450885541170.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1997969707",
    "id" : "C535CE74",
    "lastKnownWriteTime" : 1450918078,
    "path" : "~/Desktop/Dropbox/devel/mertree/R/mertree.R",
    "project_path" : "R/mertree.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}